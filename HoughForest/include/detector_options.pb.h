// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: detector_options.proto

#ifndef PROTOBUF_detector_5foptions_2eproto__INCLUDED
#define PROTOBUF_detector_5foptions_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace DetectorOptions {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_detector_5foptions_2eproto();
void protobuf_AssignDesc_detector_5foptions_2eproto();
void protobuf_ShutdownFile_detector_5foptions_2eproto();

class ObjectOptions;
class Options;

// ===================================================================

class ObjectOptions : public ::google::protobuf::Message {
 public:
  ObjectOptions();
  virtual ~ObjectOptions();

  ObjectOptions(const ObjectOptions& from);

  inline ObjectOptions& operator=(const ObjectOptions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectOptions& default_instance();

  void Swap(ObjectOptions* other);

  // implements Message ----------------------------------------------

  ObjectOptions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObjectOptions& from);
  void MergeFrom(const ObjectOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string mesh_file = 3;
  inline bool has_mesh_file() const;
  inline void clear_mesh_file();
  static const int kMeshFileFieldNumber = 3;
  inline const ::std::string& mesh_file() const;
  inline void set_mesh_file(const ::std::string& value);
  inline void set_mesh_file(const char* value);
  inline void set_mesh_file(const char* value, size_t size);
  inline ::std::string* mutable_mesh_file();
  inline ::std::string* release_mesh_file();
  inline void set_allocated_mesh_file(::std::string* mesh_file);

  // optional int32 instances = 4 [default = 1];
  inline bool has_instances() const;
  inline void clear_instances();
  static const int kInstancesFieldNumber = 4;
  inline ::google::protobuf::int32 instances() const;
  inline void set_instances(::google::protobuf::int32 value);

  // optional float nn_search_radius = 5 [default = 0.01];
  inline bool has_nn_search_radius() const;
  inline void clear_nn_search_radius();
  static const int kNnSearchRadiusFieldNumber = 5;
  inline float nn_search_radius() const;
  inline void set_nn_search_radius(float value);

  // optional int32 icp_iterations = 6 [default = 60];
  inline bool has_icp_iterations() const;
  inline void clear_icp_iterations();
  static const int kIcpIterationsFieldNumber = 6;
  inline ::google::protobuf::int32 icp_iterations() const;
  inline void set_icp_iterations(::google::protobuf::int32 value);

  // optional bool align_z_axis = 7 [default = false];
  inline bool has_align_z_axis() const;
  inline void clear_align_z_axis();
  static const int kAlignZAxisFieldNumber = 7;
  inline bool align_z_axis() const;
  inline void set_align_z_axis(bool value);

  // optional int32 max_location_hypotheses = 8 [default = 12];
  inline bool has_max_location_hypotheses() const;
  inline void clear_max_location_hypotheses();
  static const int kMaxLocationHypothesesFieldNumber = 8;
  inline ::google::protobuf::int32 max_location_hypotheses() const;
  inline void set_max_location_hypotheses(::google::protobuf::int32 value);

  // optional bool should_detect = 9 [default = true];
  inline bool has_should_detect() const;
  inline void clear_should_detect();
  static const int kShouldDetectFieldNumber = 9;
  inline bool should_detect() const;
  inline void set_should_detect(bool value);

  // @@protoc_insertion_point(class_scope:DetectorOptions.ObjectOptions)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_mesh_file();
  inline void clear_has_mesh_file();
  inline void set_has_instances();
  inline void clear_has_instances();
  inline void set_has_nn_search_radius();
  inline void clear_has_nn_search_radius();
  inline void set_has_icp_iterations();
  inline void clear_has_icp_iterations();
  inline void set_has_align_z_axis();
  inline void clear_has_align_z_axis();
  inline void set_has_max_location_hypotheses();
  inline void clear_has_max_location_hypotheses();
  inline void set_has_should_detect();
  inline void clear_has_should_detect();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* mesh_file_;
  ::google::protobuf::int32 instances_;
  float nn_search_radius_;
  ::google::protobuf::int32 icp_iterations_;
  ::google::protobuf::int32 max_location_hypotheses_;
  bool align_z_axis_;
  bool should_detect_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_detector_5foptions_2eproto();
  friend void protobuf_AssignDesc_detector_5foptions_2eproto();
  friend void protobuf_ShutdownFile_detector_5foptions_2eproto();

  void InitAsDefaultInstance();
  static ObjectOptions* default_instance_;
};
// -------------------------------------------------------------------

class Options : public ::google::protobuf::Message {
 public:
  Options();
  virtual ~Options();

  Options(const Options& from);

  inline Options& operator=(const Options& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Options& default_instance();

  void Swap(Options* other);

  // implements Message ----------------------------------------------

  Options* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Options& from);
  void MergeFrom(const Options& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DetectorOptions.ObjectOptions object_options = 1;
  inline int object_options_size() const;
  inline void clear_object_options();
  static const int kObjectOptionsFieldNumber = 1;
  inline const ::DetectorOptions::ObjectOptions& object_options(int index) const;
  inline ::DetectorOptions::ObjectOptions* mutable_object_options(int index);
  inline ::DetectorOptions::ObjectOptions* add_object_options();
  inline const ::google::protobuf::RepeatedPtrField< ::DetectorOptions::ObjectOptions >&
      object_options() const;
  inline ::google::protobuf::RepeatedPtrField< ::DetectorOptions::ObjectOptions >*
      mutable_object_options();

  // required string forest_folder = 2;
  inline bool has_forest_folder() const;
  inline void clear_forest_folder();
  static const int kForestFolderFieldNumber = 2;
  inline const ::std::string& forest_folder() const;
  inline void set_forest_folder(const ::std::string& value);
  inline void set_forest_folder(const char* value);
  inline void set_forest_folder(const char* value, size_t size);
  inline ::std::string* mutable_forest_folder();
  inline ::std::string* release_forest_folder();
  inline void set_allocated_forest_folder(::std::string* forest_folder);

  // required string caffe_definition = 3;
  inline bool has_caffe_definition() const;
  inline void clear_caffe_definition();
  static const int kCaffeDefinitionFieldNumber = 3;
  inline const ::std::string& caffe_definition() const;
  inline void set_caffe_definition(const ::std::string& value);
  inline void set_caffe_definition(const char* value);
  inline void set_caffe_definition(const char* value, size_t size);
  inline ::std::string* mutable_caffe_definition();
  inline ::std::string* release_caffe_definition();
  inline void set_allocated_caffe_definition(::std::string* caffe_definition);

  // required string caffe_weights = 4;
  inline bool has_caffe_weights() const;
  inline void clear_caffe_weights();
  static const int kCaffeWeightsFieldNumber = 4;
  inline const ::std::string& caffe_weights() const;
  inline void set_caffe_weights(const ::std::string& value);
  inline void set_caffe_weights(const char* value);
  inline void set_caffe_weights(const char* value, size_t size);
  inline ::std::string* mutable_caffe_weights();
  inline ::std::string* release_caffe_weights();
  inline void set_allocated_caffe_weights(::std::string* caffe_weights);

  // optional int32 stride = 5 [default = 4];
  inline bool has_stride() const;
  inline void clear_stride();
  static const int kStrideFieldNumber = 5;
  inline ::google::protobuf::int32 stride() const;
  inline void set_stride(::google::protobuf::int32 value);

  // optional int32 gpu = 6 [default = -1];
  inline bool has_gpu() const;
  inline void clear_gpu();
  static const int kGpuFieldNumber = 6;
  inline ::google::protobuf::int32 gpu() const;
  inline void set_gpu(::google::protobuf::int32 value);

  // optional int32 num_threads = 7 [default = 4];
  inline bool has_num_threads() const;
  inline void clear_num_threads();
  static const int kNumThreadsFieldNumber = 7;
  inline ::google::protobuf::int32 num_threads() const;
  inline void set_num_threads(::google::protobuf::int32 value);

  // optional float max_depth_range_in_patch_in_m = 8 [default = 0.25];
  inline bool has_max_depth_range_in_patch_in_m() const;
  inline void clear_max_depth_range_in_patch_in_m();
  static const int kMaxDepthRangeInPatchInMFieldNumber = 8;
  inline float max_depth_range_in_patch_in_m() const;
  inline void set_max_depth_range_in_patch_in_m(float value);

  // optional int32 batch_size = 9 [default = 100];
  inline bool has_batch_size() const;
  inline void clear_batch_size();
  static const int kBatchSizeFieldNumber = 9;
  inline ::google::protobuf::int32 batch_size() const;
  inline void set_batch_size(::google::protobuf::int32 value);

  // optional float fx = 10 [default = 575];
  inline bool has_fx() const;
  inline void clear_fx();
  static const int kFxFieldNumber = 10;
  inline float fx() const;
  inline void set_fx(float value);

  // optional float fy = 11 [default = 575];
  inline bool has_fy() const;
  inline void clear_fy();
  static const int kFyFieldNumber = 11;
  inline float fy() const;
  inline void set_fy(float value);

  // optional float cx = 12 [default = 319.5];
  inline bool has_cx() const;
  inline void clear_cx();
  static const int kCxFieldNumber = 12;
  inline float cx() const;
  inline void set_cx(float value);

  // optional float cy = 13 [default = 239.5];
  inline bool has_cy() const;
  inline void clear_cy();
  static const int kCyFieldNumber = 13;
  inline float cy() const;
  inline void set_cy(float value);

  // optional bool search_single_object_instance = 14 [default = false];
  inline bool has_search_single_object_instance() const;
  inline void clear_search_single_object_instance();
  static const int kSearchSingleObjectInstanceFieldNumber = 14;
  inline bool search_single_object_instance() const;
  inline void set_search_single_object_instance(bool value);

  // optional bool search_single_object_in_group = 15 [default = false];
  inline bool has_search_single_object_in_group() const;
  inline void clear_search_single_object_in_group();
  static const int kSearchSingleObjectInGroupFieldNumber = 15;
  inline bool search_single_object_in_group() const;
  inline void set_search_single_object_in_group(bool value);

  // optional bool use_color_similarity = 16 [default = true];
  inline bool has_use_color_similarity() const;
  inline void clear_use_color_similarity();
  static const int kUseColorSimilarityFieldNumber = 16;
  inline bool use_color_similarity() const;
  inline void set_use_color_similarity(bool value);

  // optional float similarity_coeff = 17 [default = 10];
  inline bool has_similarity_coeff() const;
  inline void clear_similarity_coeff();
  static const int kSimilarityCoeffFieldNumber = 17;
  inline float similarity_coeff() const;
  inline void set_similarity_coeff(float value);

  // optional float inliers_coeff = 18 [default = 2.5];
  inline bool has_inliers_coeff() const;
  inline void clear_inliers_coeff();
  static const int kInliersCoeffFieldNumber = 18;
  inline float inliers_coeff() const;
  inline void set_inliers_coeff(float value);

  // optional float clutter_coeff = 19 [default = 1.4];
  inline bool has_clutter_coeff() const;
  inline void clear_clutter_coeff();
  static const int kClutterCoeffFieldNumber = 19;
  inline float clutter_coeff() const;
  inline void set_clutter_coeff(float value);

  // optional float location_score_coeff = 20 [default = 1];
  inline bool has_location_score_coeff() const;
  inline void clear_location_score_coeff();
  static const int kLocationScoreCoeffFieldNumber = 20;
  inline float location_score_coeff() const;
  inline void set_location_score_coeff(float value);

  // optional float pose_score_coeff = 21 [default = 0.7];
  inline bool has_pose_score_coeff() const;
  inline void clear_pose_score_coeff();
  static const int kPoseScoreCoeffFieldNumber = 21;
  inline float pose_score_coeff() const;
  inline void set_pose_score_coeff(float value);

  // optional float group_total_explain_coeff = 22 [default = 0.5];
  inline bool has_group_total_explain_coeff() const;
  inline void clear_group_total_explain_coeff();
  static const int kGroupTotalExplainCoeffFieldNumber = 22;
  inline float group_total_explain_coeff() const;
  inline void set_group_total_explain_coeff(float value);

  // optional float group_common_explain_coeff = 23 [default = 0.3];
  inline bool has_group_common_explain_coeff() const;
  inline void clear_group_common_explain_coeff();
  static const int kGroupCommonExplainCoeffFieldNumber = 23;
  inline float group_common_explain_coeff() const;
  inline void set_group_common_explain_coeff(float value);

  // optional float inliers_threshold = 24 [default = 0.6];
  inline bool has_inliers_threshold() const;
  inline void clear_inliers_threshold();
  static const int kInliersThresholdFieldNumber = 24;
  inline float inliers_threshold() const;
  inline void set_inliers_threshold(float value);

  // optional float clutter_threshold = 25 [default = 0.6];
  inline bool has_clutter_threshold() const;
  inline void clear_clutter_threshold();
  static const int kClutterThresholdFieldNumber = 25;
  inline float clutter_threshold() const;
  inline void set_clutter_threshold(float value);

  // optional float final_score_threshold = 26 [default = 10];
  inline bool has_final_score_threshold() const;
  inline void clear_final_score_threshold();
  static const int kFinalScoreThresholdFieldNumber = 26;
  inline float final_score_threshold() const;
  inline void set_final_score_threshold(float value);

  // optional float cluster_eps_angle_threshold = 27 [default = 0.05];
  inline bool has_cluster_eps_angle_threshold() const;
  inline void clear_cluster_eps_angle_threshold();
  static const int kClusterEpsAngleThresholdFieldNumber = 27;
  inline float cluster_eps_angle_threshold() const;
  inline void set_cluster_eps_angle_threshold(float value);

  // optional int32 cluster_min_points = 28 [default = 5];
  inline bool has_cluster_min_points() const;
  inline void clear_cluster_min_points();
  static const int kClusterMinPointsFieldNumber = 28;
  inline ::google::protobuf::int32 cluster_min_points() const;
  inline void set_cluster_min_points(::google::protobuf::int32 value);

  // optional float cluster_curvature_threshold = 29 [default = 0.1];
  inline bool has_cluster_curvature_threshold() const;
  inline void clear_cluster_curvature_threshold();
  static const int kClusterCurvatureThresholdFieldNumber = 29;
  inline float cluster_curvature_threshold() const;
  inline void set_cluster_curvature_threshold(float value);

  // optional float cluster_tolerance_near = 30 [default = 0.03];
  inline bool has_cluster_tolerance_near() const;
  inline void clear_cluster_tolerance_near();
  static const int kClusterToleranceNearFieldNumber = 30;
  inline float cluster_tolerance_near() const;
  inline void set_cluster_tolerance_near(float value);

  // optional float cluster_tolerance_far = 31 [default = 0.05];
  inline bool has_cluster_tolerance_far() const;
  inline void clear_cluster_tolerance_far();
  static const int kClusterToleranceFarFieldNumber = 31;
  inline float cluster_tolerance_far() const;
  inline void set_cluster_tolerance_far(float value);

  // optional float distance_threshold = 32 [default = 1.5];
  inline bool has_distance_threshold() const;
  inline void clear_distance_threshold();
  static const int kDistanceThresholdFieldNumber = 32;
  inline float distance_threshold() const;
  inline void set_distance_threshold(float value);

  // optional bool are_objects_segmented = 33 [default = false];
  inline bool has_are_objects_segmented() const;
  inline void clear_are_objects_segmented();
  static const int kAreObjectsSegmentedFieldNumber = 33;
  inline bool are_objects_segmented() const;
  inline void set_are_objects_segmented(bool value);

  // @@protoc_insertion_point(class_scope:DetectorOptions.Options)
 private:
  inline void set_has_forest_folder();
  inline void clear_has_forest_folder();
  inline void set_has_caffe_definition();
  inline void clear_has_caffe_definition();
  inline void set_has_caffe_weights();
  inline void clear_has_caffe_weights();
  inline void set_has_stride();
  inline void clear_has_stride();
  inline void set_has_gpu();
  inline void clear_has_gpu();
  inline void set_has_num_threads();
  inline void clear_has_num_threads();
  inline void set_has_max_depth_range_in_patch_in_m();
  inline void clear_has_max_depth_range_in_patch_in_m();
  inline void set_has_batch_size();
  inline void clear_has_batch_size();
  inline void set_has_fx();
  inline void clear_has_fx();
  inline void set_has_fy();
  inline void clear_has_fy();
  inline void set_has_cx();
  inline void clear_has_cx();
  inline void set_has_cy();
  inline void clear_has_cy();
  inline void set_has_search_single_object_instance();
  inline void clear_has_search_single_object_instance();
  inline void set_has_search_single_object_in_group();
  inline void clear_has_search_single_object_in_group();
  inline void set_has_use_color_similarity();
  inline void clear_has_use_color_similarity();
  inline void set_has_similarity_coeff();
  inline void clear_has_similarity_coeff();
  inline void set_has_inliers_coeff();
  inline void clear_has_inliers_coeff();
  inline void set_has_clutter_coeff();
  inline void clear_has_clutter_coeff();
  inline void set_has_location_score_coeff();
  inline void clear_has_location_score_coeff();
  inline void set_has_pose_score_coeff();
  inline void clear_has_pose_score_coeff();
  inline void set_has_group_total_explain_coeff();
  inline void clear_has_group_total_explain_coeff();
  inline void set_has_group_common_explain_coeff();
  inline void clear_has_group_common_explain_coeff();
  inline void set_has_inliers_threshold();
  inline void clear_has_inliers_threshold();
  inline void set_has_clutter_threshold();
  inline void clear_has_clutter_threshold();
  inline void set_has_final_score_threshold();
  inline void clear_has_final_score_threshold();
  inline void set_has_cluster_eps_angle_threshold();
  inline void clear_has_cluster_eps_angle_threshold();
  inline void set_has_cluster_min_points();
  inline void clear_has_cluster_min_points();
  inline void set_has_cluster_curvature_threshold();
  inline void clear_has_cluster_curvature_threshold();
  inline void set_has_cluster_tolerance_near();
  inline void clear_has_cluster_tolerance_near();
  inline void set_has_cluster_tolerance_far();
  inline void clear_has_cluster_tolerance_far();
  inline void set_has_distance_threshold();
  inline void clear_has_distance_threshold();
  inline void set_has_are_objects_segmented();
  inline void clear_has_are_objects_segmented();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::DetectorOptions::ObjectOptions > object_options_;
  ::std::string* forest_folder_;
  ::std::string* caffe_definition_;
  ::std::string* caffe_weights_;
  ::google::protobuf::int32 stride_;
  ::google::protobuf::int32 gpu_;
  ::google::protobuf::int32 num_threads_;
  float max_depth_range_in_patch_in_m_;
  ::google::protobuf::int32 batch_size_;
  float fx_;
  float fy_;
  float cx_;
  float cy_;
  float similarity_coeff_;
  float inliers_coeff_;
  float clutter_coeff_;
  bool search_single_object_instance_;
  bool search_single_object_in_group_;
  bool use_color_similarity_;
  bool are_objects_segmented_;
  float location_score_coeff_;
  float pose_score_coeff_;
  float group_total_explain_coeff_;
  float group_common_explain_coeff_;
  float inliers_threshold_;
  float clutter_threshold_;
  float final_score_threshold_;
  float cluster_eps_angle_threshold_;
  ::google::protobuf::int32 cluster_min_points_;
  float cluster_curvature_threshold_;
  float cluster_tolerance_near_;
  float cluster_tolerance_far_;
  float distance_threshold_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(33 + 31) / 32];

  friend void  protobuf_AddDesc_detector_5foptions_2eproto();
  friend void protobuf_AssignDesc_detector_5foptions_2eproto();
  friend void protobuf_ShutdownFile_detector_5foptions_2eproto();

  void InitAsDefaultInstance();
  static Options* default_instance_;
};
// ===================================================================


// ===================================================================

// ObjectOptions

// required string name = 2;
inline bool ObjectOptions::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectOptions::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectOptions::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectOptions::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ObjectOptions::name() const {
  return *name_;
}
inline void ObjectOptions::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ObjectOptions::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ObjectOptions::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ObjectOptions::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ObjectOptions::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ObjectOptions::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string mesh_file = 3;
inline bool ObjectOptions::has_mesh_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectOptions::set_has_mesh_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObjectOptions::clear_has_mesh_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObjectOptions::clear_mesh_file() {
  if (mesh_file_ != &::google::protobuf::internal::kEmptyString) {
    mesh_file_->clear();
  }
  clear_has_mesh_file();
}
inline const ::std::string& ObjectOptions::mesh_file() const {
  return *mesh_file_;
}
inline void ObjectOptions::set_mesh_file(const ::std::string& value) {
  set_has_mesh_file();
  if (mesh_file_ == &::google::protobuf::internal::kEmptyString) {
    mesh_file_ = new ::std::string;
  }
  mesh_file_->assign(value);
}
inline void ObjectOptions::set_mesh_file(const char* value) {
  set_has_mesh_file();
  if (mesh_file_ == &::google::protobuf::internal::kEmptyString) {
    mesh_file_ = new ::std::string;
  }
  mesh_file_->assign(value);
}
inline void ObjectOptions::set_mesh_file(const char* value, size_t size) {
  set_has_mesh_file();
  if (mesh_file_ == &::google::protobuf::internal::kEmptyString) {
    mesh_file_ = new ::std::string;
  }
  mesh_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ObjectOptions::mutable_mesh_file() {
  set_has_mesh_file();
  if (mesh_file_ == &::google::protobuf::internal::kEmptyString) {
    mesh_file_ = new ::std::string;
  }
  return mesh_file_;
}
inline ::std::string* ObjectOptions::release_mesh_file() {
  clear_has_mesh_file();
  if (mesh_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mesh_file_;
    mesh_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ObjectOptions::set_allocated_mesh_file(::std::string* mesh_file) {
  if (mesh_file_ != &::google::protobuf::internal::kEmptyString) {
    delete mesh_file_;
  }
  if (mesh_file) {
    set_has_mesh_file();
    mesh_file_ = mesh_file;
  } else {
    clear_has_mesh_file();
    mesh_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 instances = 4 [default = 1];
inline bool ObjectOptions::has_instances() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObjectOptions::set_has_instances() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObjectOptions::clear_has_instances() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObjectOptions::clear_instances() {
  instances_ = 1;
  clear_has_instances();
}
inline ::google::protobuf::int32 ObjectOptions::instances() const {
  return instances_;
}
inline void ObjectOptions::set_instances(::google::protobuf::int32 value) {
  set_has_instances();
  instances_ = value;
}

// optional float nn_search_radius = 5 [default = 0.01];
inline bool ObjectOptions::has_nn_search_radius() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ObjectOptions::set_has_nn_search_radius() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ObjectOptions::clear_has_nn_search_radius() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ObjectOptions::clear_nn_search_radius() {
  nn_search_radius_ = 0.01f;
  clear_has_nn_search_radius();
}
inline float ObjectOptions::nn_search_radius() const {
  return nn_search_radius_;
}
inline void ObjectOptions::set_nn_search_radius(float value) {
  set_has_nn_search_radius();
  nn_search_radius_ = value;
}

// optional int32 icp_iterations = 6 [default = 60];
inline bool ObjectOptions::has_icp_iterations() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ObjectOptions::set_has_icp_iterations() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ObjectOptions::clear_has_icp_iterations() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ObjectOptions::clear_icp_iterations() {
  icp_iterations_ = 60;
  clear_has_icp_iterations();
}
inline ::google::protobuf::int32 ObjectOptions::icp_iterations() const {
  return icp_iterations_;
}
inline void ObjectOptions::set_icp_iterations(::google::protobuf::int32 value) {
  set_has_icp_iterations();
  icp_iterations_ = value;
}

// optional bool align_z_axis = 7 [default = false];
inline bool ObjectOptions::has_align_z_axis() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ObjectOptions::set_has_align_z_axis() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ObjectOptions::clear_has_align_z_axis() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ObjectOptions::clear_align_z_axis() {
  align_z_axis_ = false;
  clear_has_align_z_axis();
}
inline bool ObjectOptions::align_z_axis() const {
  return align_z_axis_;
}
inline void ObjectOptions::set_align_z_axis(bool value) {
  set_has_align_z_axis();
  align_z_axis_ = value;
}

// optional int32 max_location_hypotheses = 8 [default = 12];
inline bool ObjectOptions::has_max_location_hypotheses() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ObjectOptions::set_has_max_location_hypotheses() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ObjectOptions::clear_has_max_location_hypotheses() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ObjectOptions::clear_max_location_hypotheses() {
  max_location_hypotheses_ = 12;
  clear_has_max_location_hypotheses();
}
inline ::google::protobuf::int32 ObjectOptions::max_location_hypotheses() const {
  return max_location_hypotheses_;
}
inline void ObjectOptions::set_max_location_hypotheses(::google::protobuf::int32 value) {
  set_has_max_location_hypotheses();
  max_location_hypotheses_ = value;
}

// optional bool should_detect = 9 [default = true];
inline bool ObjectOptions::has_should_detect() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ObjectOptions::set_has_should_detect() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ObjectOptions::clear_has_should_detect() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ObjectOptions::clear_should_detect() {
  should_detect_ = true;
  clear_has_should_detect();
}
inline bool ObjectOptions::should_detect() const {
  return should_detect_;
}
inline void ObjectOptions::set_should_detect(bool value) {
  set_has_should_detect();
  should_detect_ = value;
}

// -------------------------------------------------------------------

// Options

// repeated .DetectorOptions.ObjectOptions object_options = 1;
inline int Options::object_options_size() const {
  return object_options_.size();
}
inline void Options::clear_object_options() {
  object_options_.Clear();
}
inline const ::DetectorOptions::ObjectOptions& Options::object_options(int index) const {
  return object_options_.Get(index);
}
inline ::DetectorOptions::ObjectOptions* Options::mutable_object_options(int index) {
  return object_options_.Mutable(index);
}
inline ::DetectorOptions::ObjectOptions* Options::add_object_options() {
  return object_options_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DetectorOptions::ObjectOptions >&
Options::object_options() const {
  return object_options_;
}
inline ::google::protobuf::RepeatedPtrField< ::DetectorOptions::ObjectOptions >*
Options::mutable_object_options() {
  return &object_options_;
}

// required string forest_folder = 2;
inline bool Options::has_forest_folder() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Options::set_has_forest_folder() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Options::clear_has_forest_folder() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Options::clear_forest_folder() {
  if (forest_folder_ != &::google::protobuf::internal::kEmptyString) {
    forest_folder_->clear();
  }
  clear_has_forest_folder();
}
inline const ::std::string& Options::forest_folder() const {
  return *forest_folder_;
}
inline void Options::set_forest_folder(const ::std::string& value) {
  set_has_forest_folder();
  if (forest_folder_ == &::google::protobuf::internal::kEmptyString) {
    forest_folder_ = new ::std::string;
  }
  forest_folder_->assign(value);
}
inline void Options::set_forest_folder(const char* value) {
  set_has_forest_folder();
  if (forest_folder_ == &::google::protobuf::internal::kEmptyString) {
    forest_folder_ = new ::std::string;
  }
  forest_folder_->assign(value);
}
inline void Options::set_forest_folder(const char* value, size_t size) {
  set_has_forest_folder();
  if (forest_folder_ == &::google::protobuf::internal::kEmptyString) {
    forest_folder_ = new ::std::string;
  }
  forest_folder_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Options::mutable_forest_folder() {
  set_has_forest_folder();
  if (forest_folder_ == &::google::protobuf::internal::kEmptyString) {
    forest_folder_ = new ::std::string;
  }
  return forest_folder_;
}
inline ::std::string* Options::release_forest_folder() {
  clear_has_forest_folder();
  if (forest_folder_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = forest_folder_;
    forest_folder_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Options::set_allocated_forest_folder(::std::string* forest_folder) {
  if (forest_folder_ != &::google::protobuf::internal::kEmptyString) {
    delete forest_folder_;
  }
  if (forest_folder) {
    set_has_forest_folder();
    forest_folder_ = forest_folder;
  } else {
    clear_has_forest_folder();
    forest_folder_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string caffe_definition = 3;
inline bool Options::has_caffe_definition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Options::set_has_caffe_definition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Options::clear_has_caffe_definition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Options::clear_caffe_definition() {
  if (caffe_definition_ != &::google::protobuf::internal::kEmptyString) {
    caffe_definition_->clear();
  }
  clear_has_caffe_definition();
}
inline const ::std::string& Options::caffe_definition() const {
  return *caffe_definition_;
}
inline void Options::set_caffe_definition(const ::std::string& value) {
  set_has_caffe_definition();
  if (caffe_definition_ == &::google::protobuf::internal::kEmptyString) {
    caffe_definition_ = new ::std::string;
  }
  caffe_definition_->assign(value);
}
inline void Options::set_caffe_definition(const char* value) {
  set_has_caffe_definition();
  if (caffe_definition_ == &::google::protobuf::internal::kEmptyString) {
    caffe_definition_ = new ::std::string;
  }
  caffe_definition_->assign(value);
}
inline void Options::set_caffe_definition(const char* value, size_t size) {
  set_has_caffe_definition();
  if (caffe_definition_ == &::google::protobuf::internal::kEmptyString) {
    caffe_definition_ = new ::std::string;
  }
  caffe_definition_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Options::mutable_caffe_definition() {
  set_has_caffe_definition();
  if (caffe_definition_ == &::google::protobuf::internal::kEmptyString) {
    caffe_definition_ = new ::std::string;
  }
  return caffe_definition_;
}
inline ::std::string* Options::release_caffe_definition() {
  clear_has_caffe_definition();
  if (caffe_definition_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = caffe_definition_;
    caffe_definition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Options::set_allocated_caffe_definition(::std::string* caffe_definition) {
  if (caffe_definition_ != &::google::protobuf::internal::kEmptyString) {
    delete caffe_definition_;
  }
  if (caffe_definition) {
    set_has_caffe_definition();
    caffe_definition_ = caffe_definition;
  } else {
    clear_has_caffe_definition();
    caffe_definition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string caffe_weights = 4;
inline bool Options::has_caffe_weights() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Options::set_has_caffe_weights() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Options::clear_has_caffe_weights() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Options::clear_caffe_weights() {
  if (caffe_weights_ != &::google::protobuf::internal::kEmptyString) {
    caffe_weights_->clear();
  }
  clear_has_caffe_weights();
}
inline const ::std::string& Options::caffe_weights() const {
  return *caffe_weights_;
}
inline void Options::set_caffe_weights(const ::std::string& value) {
  set_has_caffe_weights();
  if (caffe_weights_ == &::google::protobuf::internal::kEmptyString) {
    caffe_weights_ = new ::std::string;
  }
  caffe_weights_->assign(value);
}
inline void Options::set_caffe_weights(const char* value) {
  set_has_caffe_weights();
  if (caffe_weights_ == &::google::protobuf::internal::kEmptyString) {
    caffe_weights_ = new ::std::string;
  }
  caffe_weights_->assign(value);
}
inline void Options::set_caffe_weights(const char* value, size_t size) {
  set_has_caffe_weights();
  if (caffe_weights_ == &::google::protobuf::internal::kEmptyString) {
    caffe_weights_ = new ::std::string;
  }
  caffe_weights_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Options::mutable_caffe_weights() {
  set_has_caffe_weights();
  if (caffe_weights_ == &::google::protobuf::internal::kEmptyString) {
    caffe_weights_ = new ::std::string;
  }
  return caffe_weights_;
}
inline ::std::string* Options::release_caffe_weights() {
  clear_has_caffe_weights();
  if (caffe_weights_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = caffe_weights_;
    caffe_weights_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Options::set_allocated_caffe_weights(::std::string* caffe_weights) {
  if (caffe_weights_ != &::google::protobuf::internal::kEmptyString) {
    delete caffe_weights_;
  }
  if (caffe_weights) {
    set_has_caffe_weights();
    caffe_weights_ = caffe_weights;
  } else {
    clear_has_caffe_weights();
    caffe_weights_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 stride = 5 [default = 4];
inline bool Options::has_stride() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Options::set_has_stride() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Options::clear_has_stride() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Options::clear_stride() {
  stride_ = 4;
  clear_has_stride();
}
inline ::google::protobuf::int32 Options::stride() const {
  return stride_;
}
inline void Options::set_stride(::google::protobuf::int32 value) {
  set_has_stride();
  stride_ = value;
}

// optional int32 gpu = 6 [default = -1];
inline bool Options::has_gpu() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Options::set_has_gpu() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Options::clear_has_gpu() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Options::clear_gpu() {
  gpu_ = -1;
  clear_has_gpu();
}
inline ::google::protobuf::int32 Options::gpu() const {
  return gpu_;
}
inline void Options::set_gpu(::google::protobuf::int32 value) {
  set_has_gpu();
  gpu_ = value;
}

// optional int32 num_threads = 7 [default = 4];
inline bool Options::has_num_threads() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Options::set_has_num_threads() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Options::clear_has_num_threads() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Options::clear_num_threads() {
  num_threads_ = 4;
  clear_has_num_threads();
}
inline ::google::protobuf::int32 Options::num_threads() const {
  return num_threads_;
}
inline void Options::set_num_threads(::google::protobuf::int32 value) {
  set_has_num_threads();
  num_threads_ = value;
}

// optional float max_depth_range_in_patch_in_m = 8 [default = 0.25];
inline bool Options::has_max_depth_range_in_patch_in_m() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Options::set_has_max_depth_range_in_patch_in_m() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Options::clear_has_max_depth_range_in_patch_in_m() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Options::clear_max_depth_range_in_patch_in_m() {
  max_depth_range_in_patch_in_m_ = 0.25f;
  clear_has_max_depth_range_in_patch_in_m();
}
inline float Options::max_depth_range_in_patch_in_m() const {
  return max_depth_range_in_patch_in_m_;
}
inline void Options::set_max_depth_range_in_patch_in_m(float value) {
  set_has_max_depth_range_in_patch_in_m();
  max_depth_range_in_patch_in_m_ = value;
}

// optional int32 batch_size = 9 [default = 100];
inline bool Options::has_batch_size() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Options::set_has_batch_size() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Options::clear_has_batch_size() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Options::clear_batch_size() {
  batch_size_ = 100;
  clear_has_batch_size();
}
inline ::google::protobuf::int32 Options::batch_size() const {
  return batch_size_;
}
inline void Options::set_batch_size(::google::protobuf::int32 value) {
  set_has_batch_size();
  batch_size_ = value;
}

// optional float fx = 10 [default = 575];
inline bool Options::has_fx() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Options::set_has_fx() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Options::clear_has_fx() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Options::clear_fx() {
  fx_ = 575;
  clear_has_fx();
}
inline float Options::fx() const {
  return fx_;
}
inline void Options::set_fx(float value) {
  set_has_fx();
  fx_ = value;
}

// optional float fy = 11 [default = 575];
inline bool Options::has_fy() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Options::set_has_fy() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Options::clear_has_fy() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Options::clear_fy() {
  fy_ = 575;
  clear_has_fy();
}
inline float Options::fy() const {
  return fy_;
}
inline void Options::set_fy(float value) {
  set_has_fy();
  fy_ = value;
}

// optional float cx = 12 [default = 319.5];
inline bool Options::has_cx() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Options::set_has_cx() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Options::clear_has_cx() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Options::clear_cx() {
  cx_ = 319.5f;
  clear_has_cx();
}
inline float Options::cx() const {
  return cx_;
}
inline void Options::set_cx(float value) {
  set_has_cx();
  cx_ = value;
}

// optional float cy = 13 [default = 239.5];
inline bool Options::has_cy() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Options::set_has_cy() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Options::clear_has_cy() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Options::clear_cy() {
  cy_ = 239.5f;
  clear_has_cy();
}
inline float Options::cy() const {
  return cy_;
}
inline void Options::set_cy(float value) {
  set_has_cy();
  cy_ = value;
}

// optional bool search_single_object_instance = 14 [default = false];
inline bool Options::has_search_single_object_instance() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Options::set_has_search_single_object_instance() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Options::clear_has_search_single_object_instance() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Options::clear_search_single_object_instance() {
  search_single_object_instance_ = false;
  clear_has_search_single_object_instance();
}
inline bool Options::search_single_object_instance() const {
  return search_single_object_instance_;
}
inline void Options::set_search_single_object_instance(bool value) {
  set_has_search_single_object_instance();
  search_single_object_instance_ = value;
}

// optional bool search_single_object_in_group = 15 [default = false];
inline bool Options::has_search_single_object_in_group() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Options::set_has_search_single_object_in_group() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Options::clear_has_search_single_object_in_group() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Options::clear_search_single_object_in_group() {
  search_single_object_in_group_ = false;
  clear_has_search_single_object_in_group();
}
inline bool Options::search_single_object_in_group() const {
  return search_single_object_in_group_;
}
inline void Options::set_search_single_object_in_group(bool value) {
  set_has_search_single_object_in_group();
  search_single_object_in_group_ = value;
}

// optional bool use_color_similarity = 16 [default = true];
inline bool Options::has_use_color_similarity() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Options::set_has_use_color_similarity() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Options::clear_has_use_color_similarity() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Options::clear_use_color_similarity() {
  use_color_similarity_ = true;
  clear_has_use_color_similarity();
}
inline bool Options::use_color_similarity() const {
  return use_color_similarity_;
}
inline void Options::set_use_color_similarity(bool value) {
  set_has_use_color_similarity();
  use_color_similarity_ = value;
}

// optional float similarity_coeff = 17 [default = 10];
inline bool Options::has_similarity_coeff() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Options::set_has_similarity_coeff() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Options::clear_has_similarity_coeff() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Options::clear_similarity_coeff() {
  similarity_coeff_ = 10;
  clear_has_similarity_coeff();
}
inline float Options::similarity_coeff() const {
  return similarity_coeff_;
}
inline void Options::set_similarity_coeff(float value) {
  set_has_similarity_coeff();
  similarity_coeff_ = value;
}

// optional float inliers_coeff = 18 [default = 2.5];
inline bool Options::has_inliers_coeff() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Options::set_has_inliers_coeff() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Options::clear_has_inliers_coeff() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Options::clear_inliers_coeff() {
  inliers_coeff_ = 2.5f;
  clear_has_inliers_coeff();
}
inline float Options::inliers_coeff() const {
  return inliers_coeff_;
}
inline void Options::set_inliers_coeff(float value) {
  set_has_inliers_coeff();
  inliers_coeff_ = value;
}

// optional float clutter_coeff = 19 [default = 1.4];
inline bool Options::has_clutter_coeff() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Options::set_has_clutter_coeff() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Options::clear_has_clutter_coeff() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Options::clear_clutter_coeff() {
  clutter_coeff_ = 1.4f;
  clear_has_clutter_coeff();
}
inline float Options::clutter_coeff() const {
  return clutter_coeff_;
}
inline void Options::set_clutter_coeff(float value) {
  set_has_clutter_coeff();
  clutter_coeff_ = value;
}

// optional float location_score_coeff = 20 [default = 1];
inline bool Options::has_location_score_coeff() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Options::set_has_location_score_coeff() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Options::clear_has_location_score_coeff() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Options::clear_location_score_coeff() {
  location_score_coeff_ = 1;
  clear_has_location_score_coeff();
}
inline float Options::location_score_coeff() const {
  return location_score_coeff_;
}
inline void Options::set_location_score_coeff(float value) {
  set_has_location_score_coeff();
  location_score_coeff_ = value;
}

// optional float pose_score_coeff = 21 [default = 0.7];
inline bool Options::has_pose_score_coeff() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Options::set_has_pose_score_coeff() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Options::clear_has_pose_score_coeff() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Options::clear_pose_score_coeff() {
  pose_score_coeff_ = 0.7f;
  clear_has_pose_score_coeff();
}
inline float Options::pose_score_coeff() const {
  return pose_score_coeff_;
}
inline void Options::set_pose_score_coeff(float value) {
  set_has_pose_score_coeff();
  pose_score_coeff_ = value;
}

// optional float group_total_explain_coeff = 22 [default = 0.5];
inline bool Options::has_group_total_explain_coeff() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Options::set_has_group_total_explain_coeff() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Options::clear_has_group_total_explain_coeff() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Options::clear_group_total_explain_coeff() {
  group_total_explain_coeff_ = 0.5f;
  clear_has_group_total_explain_coeff();
}
inline float Options::group_total_explain_coeff() const {
  return group_total_explain_coeff_;
}
inline void Options::set_group_total_explain_coeff(float value) {
  set_has_group_total_explain_coeff();
  group_total_explain_coeff_ = value;
}

// optional float group_common_explain_coeff = 23 [default = 0.3];
inline bool Options::has_group_common_explain_coeff() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Options::set_has_group_common_explain_coeff() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Options::clear_has_group_common_explain_coeff() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Options::clear_group_common_explain_coeff() {
  group_common_explain_coeff_ = 0.3f;
  clear_has_group_common_explain_coeff();
}
inline float Options::group_common_explain_coeff() const {
  return group_common_explain_coeff_;
}
inline void Options::set_group_common_explain_coeff(float value) {
  set_has_group_common_explain_coeff();
  group_common_explain_coeff_ = value;
}

// optional float inliers_threshold = 24 [default = 0.6];
inline bool Options::has_inliers_threshold() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Options::set_has_inliers_threshold() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Options::clear_has_inliers_threshold() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Options::clear_inliers_threshold() {
  inliers_threshold_ = 0.6f;
  clear_has_inliers_threshold();
}
inline float Options::inliers_threshold() const {
  return inliers_threshold_;
}
inline void Options::set_inliers_threshold(float value) {
  set_has_inliers_threshold();
  inliers_threshold_ = value;
}

// optional float clutter_threshold = 25 [default = 0.6];
inline bool Options::has_clutter_threshold() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Options::set_has_clutter_threshold() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Options::clear_has_clutter_threshold() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Options::clear_clutter_threshold() {
  clutter_threshold_ = 0.6f;
  clear_has_clutter_threshold();
}
inline float Options::clutter_threshold() const {
  return clutter_threshold_;
}
inline void Options::set_clutter_threshold(float value) {
  set_has_clutter_threshold();
  clutter_threshold_ = value;
}

// optional float final_score_threshold = 26 [default = 10];
inline bool Options::has_final_score_threshold() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Options::set_has_final_score_threshold() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Options::clear_has_final_score_threshold() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Options::clear_final_score_threshold() {
  final_score_threshold_ = 10;
  clear_has_final_score_threshold();
}
inline float Options::final_score_threshold() const {
  return final_score_threshold_;
}
inline void Options::set_final_score_threshold(float value) {
  set_has_final_score_threshold();
  final_score_threshold_ = value;
}

// optional float cluster_eps_angle_threshold = 27 [default = 0.05];
inline bool Options::has_cluster_eps_angle_threshold() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Options::set_has_cluster_eps_angle_threshold() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Options::clear_has_cluster_eps_angle_threshold() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Options::clear_cluster_eps_angle_threshold() {
  cluster_eps_angle_threshold_ = 0.05f;
  clear_has_cluster_eps_angle_threshold();
}
inline float Options::cluster_eps_angle_threshold() const {
  return cluster_eps_angle_threshold_;
}
inline void Options::set_cluster_eps_angle_threshold(float value) {
  set_has_cluster_eps_angle_threshold();
  cluster_eps_angle_threshold_ = value;
}

// optional int32 cluster_min_points = 28 [default = 5];
inline bool Options::has_cluster_min_points() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Options::set_has_cluster_min_points() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Options::clear_has_cluster_min_points() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Options::clear_cluster_min_points() {
  cluster_min_points_ = 5;
  clear_has_cluster_min_points();
}
inline ::google::protobuf::int32 Options::cluster_min_points() const {
  return cluster_min_points_;
}
inline void Options::set_cluster_min_points(::google::protobuf::int32 value) {
  set_has_cluster_min_points();
  cluster_min_points_ = value;
}

// optional float cluster_curvature_threshold = 29 [default = 0.1];
inline bool Options::has_cluster_curvature_threshold() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Options::set_has_cluster_curvature_threshold() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Options::clear_has_cluster_curvature_threshold() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Options::clear_cluster_curvature_threshold() {
  cluster_curvature_threshold_ = 0.1f;
  clear_has_cluster_curvature_threshold();
}
inline float Options::cluster_curvature_threshold() const {
  return cluster_curvature_threshold_;
}
inline void Options::set_cluster_curvature_threshold(float value) {
  set_has_cluster_curvature_threshold();
  cluster_curvature_threshold_ = value;
}

// optional float cluster_tolerance_near = 30 [default = 0.03];
inline bool Options::has_cluster_tolerance_near() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Options::set_has_cluster_tolerance_near() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Options::clear_has_cluster_tolerance_near() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Options::clear_cluster_tolerance_near() {
  cluster_tolerance_near_ = 0.03f;
  clear_has_cluster_tolerance_near();
}
inline float Options::cluster_tolerance_near() const {
  return cluster_tolerance_near_;
}
inline void Options::set_cluster_tolerance_near(float value) {
  set_has_cluster_tolerance_near();
  cluster_tolerance_near_ = value;
}

// optional float cluster_tolerance_far = 31 [default = 0.05];
inline bool Options::has_cluster_tolerance_far() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Options::set_has_cluster_tolerance_far() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Options::clear_has_cluster_tolerance_far() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Options::clear_cluster_tolerance_far() {
  cluster_tolerance_far_ = 0.05f;
  clear_has_cluster_tolerance_far();
}
inline float Options::cluster_tolerance_far() const {
  return cluster_tolerance_far_;
}
inline void Options::set_cluster_tolerance_far(float value) {
  set_has_cluster_tolerance_far();
  cluster_tolerance_far_ = value;
}

// optional float distance_threshold = 32 [default = 1.5];
inline bool Options::has_distance_threshold() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Options::set_has_distance_threshold() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Options::clear_has_distance_threshold() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Options::clear_distance_threshold() {
  distance_threshold_ = 1.5f;
  clear_has_distance_threshold();
}
inline float Options::distance_threshold() const {
  return distance_threshold_;
}
inline void Options::set_distance_threshold(float value) {
  set_has_distance_threshold();
  distance_threshold_ = value;
}

// optional bool are_objects_segmented = 33 [default = false];
inline bool Options::has_are_objects_segmented() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Options::set_has_are_objects_segmented() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Options::clear_has_are_objects_segmented() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void Options::clear_are_objects_segmented() {
  are_objects_segmented_ = false;
  clear_has_are_objects_segmented();
}
inline bool Options::are_objects_segmented() const {
  return are_objects_segmented_;
}
inline void Options::set_are_objects_segmented(bool value) {
  set_has_are_objects_segmented();
  are_objects_segmented_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace DetectorOptions

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_detector_5foptions_2eproto__INCLUDED
