#include <Eigen/Dense>
#include <gflags/gflags.h>
#include <glog/logging.h>
#include <HFTrain.h>
#include <HFTest.h>
#include <boost/algorithm/string.hpp>


DEFINE_bool(train, false, "Train a forest");
DEFINE_bool(test, false, "Test image of folder");
DEFINE_bool(learn_transitions, false, "Learn transitions between leaf nodes of a forest");
DEFINE_bool(save_forest_map, false, "Save map from poses to leaf ids");
DEFINE_string(input, "", "Input file containing training vectors from patches forwarded to the Deep Net");
DEFINE_string(output, ".", "Set output folder of the forest" );
DEFINE_int32(trees, 3, "Set Number of trees. Default: 3");
DEFINE_int32(min_samples, 30, "Set minimum samples of nodes");
DEFINE_int32(tests_per_node, 30, "Random tests per node");
DEFINE_int32(thresholds_per_test, 10, "Random thresholds per test");
DEFINE_int32(threads_per_tree, 8, "Set number of CPU cores per tree. Usually above 8 there is no speedup, use the rest for parallel trees.");
DEFINE_int32(threads_for_parallel_trees, 1, "Set number of parallel trees. Total threads is threads_per_tree * threads_per_parallel_trees");
DEFINE_int32(start_tree_no, 0, "Start tree number X, i.e. treeX.dat");

DEFINE_int32(patch_size_in_voxels, -1, "Patch Size in Voxels used in Patch extraction");
DEFINE_double(voxel_size_in_m, -1, "Voxel size in meters, used in Patch extraction");

DEFINE_string(detector_options_file, "", "Filename containing the detector options. Automatically generated by the generate_scripts.sh");
DEFINE_string(output_folder, "", "Output folder to save the results of the test images");

// debugging
DEFINE_bool(show_scene, false, "Show the clustered scene with the plane removed if the option is set");
DEFINE_bool(visualize_hypotheses, false, "Show all hypotheses generated *for debugging*");

int main(int argc, char** argv)
{
    google::InitGoogleLogging(argv[0]);

    #ifndef GFLAGS_GFLAGS_H_
      namespace gflags = google;
    #endif

    gflags::ParseCommandLineFlags(&argc, &argv, true);


    if(FLAGS_train){

        CHECK_GT(FLAGS_input.size(), 0) << "No input file specified";
        CHECK_GT(FLAGS_output.size(), 0) << "No output folder specified";
        CHECK_GT(FLAGS_trees, 0) << "You should train at least one tree";        
        CHECK_GT(FLAGS_min_samples, 0) << "min_samples should be greater than zero";
        CHECK_GT(FLAGS_tests_per_node, 0) << "There should be at least one test per node";
        CHECK_GT(FLAGS_thresholds_per_test, 0) << "There should be at least one threshold per test";
        CHECK_GT(FLAGS_threads_per_tree, 0) << "You should use at least one thread per tree";
        CHECK_GT(FLAGS_threads_for_parallel_trees, 0) << "You should use at least one thread for parallel trees";
        CHECK_GT(FLAGS_patch_size_in_voxels, 0) << "You should specify the Patch Size in Voxels (--patch_size_in_voxels)";
        CHECK_GT(FLAGS_voxel_size_in_m, 0) << "Shoud should specify the Voxel Size in Meters (--voxel_size_in_m)";
        HFTrain hf;
        hf.setNumTrees(FLAGS_trees);        
        hf.setMinSamples(FLAGS_min_samples);
        hf.setTestsPerNode(FLAGS_tests_per_node);
        hf.setThresPerTest(FLAGS_thresholds_per_test);
        hf.setInputPatchesFilename(FLAGS_input);
        hf.setOutputFolder(FLAGS_output);
        hf.setStartTreeNo(FLAGS_start_tree_no);
        hf.setNumberOfThreads(FLAGS_threads_per_tree, FLAGS_threads_for_parallel_trees);
        hf.setPatchSizeInVoxels(FLAGS_patch_size_in_voxels);
        hf.setVoxelSizeInM(FLAGS_voxel_size_in_m);
        hf.train();
    }

    else if(FLAGS_test){       

        HFTest ht;
        ht.DetectObjects();

    }

    return 0;
}
